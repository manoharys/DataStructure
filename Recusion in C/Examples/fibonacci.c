/*
 ****Fibonacci series using recursion****
   Fibonacci series can be generated by adding two preceding terms
   -> 0 1 1 2 3 5 8....

   Adding two preceding values in the sense adding (n-2) + (n-1) values
   algo:
       fibo(n){
         if(n<=1) return n
         return fibo(n-2) + fibo(n-1) }

   Time complexity : ~ O(2^n)

   Since above method is excessive recursion where same function called recursive with same parameters.
   So to improve above method we utilize memoization technique.
   Storing result of function and utilizing when the function called or avoid excessive recursion
   this approach is called as memoization.

   To retain a result we should make use of static or global variables.

   algo:
      static arr[] = {-1. -1. -1. -1. -1......} // declare a static arr and assign minus -1 values to it.

      int fibo(n){
           if(n<=1) return n
           if(arr[n-2] == -1){
             arr[n-2] = fibo(n-2);
           }
           if(arr[n-1] == -1){
             arr[n-1] = fibo(n-1);
           }
           return arr[n-2] + arr[n-1]
      }
    For any given value of n there will be n+1 recursive calls therefore,
    Time complexity = O(n)
*/

 #include<stdio.h>

 int fibo(int n);

 static arr[100];
 int main(){
   int value;
   for(int i=0;i<100;i++){arr[i] = -1;}
   printf("Value : ");
   scanf("%d", &value);
   printf("Result : %d ", fibo(value));
   printf("Result : %d ", fiboUpdated(value));
 }

 int fibo(int n) {
   if(n <= 1){
     return n;
   }
   return fibo(n-2) + fibo(n-1);
 }

 int fiboUpdated(int n){
    if(n<=1) return n;
    if(arr[n-2] == -1){
     arr[n-2] = fiboUpdated(n-2);
    }
    if(arr[n-1] == -1){
      arr[n-1] = fiboUpdated(n-1);
    }
    return arr[n-2] + arr[n-1];
}












